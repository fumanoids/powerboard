/*
 * msg_time.c
 *
 *  Created on: 14.11.2011
 *      Author: lutz
 */

#include <flawless/platform/system.h>
#include <flawless/timer/swTimer.h>
#include <flawless/init/systemInitializer.h>
#include <flawless/platform/hwTimer.h>

#define SW_TIMER_MAX_HANDLES 8U

#define MICROSECONDS_PER_MILLISECOND 1000U

typedef struct st_callbackHandle
{
	timerCallback_t callback;
	hw_timerTicks interval;
	int32_t tickCounter;
	bool oneShot;
} callbackHandle_t;

static callbackHandle_t g_swTimerHandles[SW_TIMER_MAX_HANDLES];

static int32_t g_ticksLastSetup = 0U;

bool swTimer_registerOnTimer(const timerCallback_t i_callback, timerInterval_t intervalInMS ,bool oneShot)
{
	bool ret = false;
	uint32_t intervalUS = intervalInMS * MICROSECONDS_PER_MILLISECOND;
	hw_timerTicks ticksToSet = hw_timerGetTicksForInterval_us(intervalUS);
	int32_t minimumTicks = ticksToSet;
	uint8_t i = 0;
	system_mutex_lock();
	const hw_timerTicks ticksElapsed = hw_timerGetTicksElapsed();

	if (NULL != i_callback)
	{
		for (i = 0; i < SW_TIMER_MAX_HANDLES; ++i)
		{
			if (NULL != g_swTimerHandles[i].callback)
			{
				g_swTimerHandles[i].tickCounter -= ticksElapsed;
				minimumTicks = MIN(minimumTicks, g_swTimerHandles[i].tickCounter);
			}
			if ((false == ret) &&
				(NULL == g_swTimerHandles[i].callback ||
				i_callback == g_swTimerHandles[i].callback))
			{
				g_swTimerHandles[i].callback = i_callback;
				g_swTimerHandles[i].interval = ticksToSet;
				g_swTimerHandles[i].tickCounter = ticksToSet;
				g_swTimerHandles[i].oneShot = oneShot;
				ret = true;
			}
		}
	}
	/* setup HW timer */
	hw_timerSetupTimer(minimumTicks);
	g_ticksLastSetup = minimumTicks;

	system_mutex_unlock();
	return ret;
}

bool swTimer_unRegisterFromTimer(const timerCallback_t i_callback)
{
	bool ret = false;
	uint8_t i = 0;
	system_mutex_lock();
	if (NULL != i_callback)
	{
		for (i = 0U; i < SW_TIMER_MAX_HANDLES; ++i)
		{
			if (i_callback == g_swTimerHandles[i].callback)
			{
				g_swTimerHandles[i].callback = NULL;
				ret = true;
				break;
			}
		}
	}
	system_mutex_unlock();
	return ret;
}

void swTimer_trigger()
{
	uint8_t i;
	hw_timerTicks nextInterval = 0xffffffff;
	for (i = 0U; i < SW_TIMER_MAX_HANDLES; ++i)
	{
		volatile callbackHandle_t *handle = &(g_swTimerHandles[i]);
		if (NULL != handle->callback)
		{
			handle->tickCounter -= g_ticksLastSetup;
			if (0 >= handle->tickCounter) /* timer ran out */
			{
				(void)(handle->callback)();
				if (false == handle->oneShot) /* reschedule? */
				{
					handle->tickCounter += handle->interval;
				} else
				{
					handle->callback = NULL;
				}
			}
			if ((NULL != handle->callback)) /* reschedule? */
			{
				nextInterval = MIN(nextInterval, (hw_timerTicks)MAX(0,handle->tickCounter));
			}
		}
	}
	if (0xffffffff != nextInterval)
	{
		g_ticksLastSetup = nextInterval;
		hw_timerSetupTimer(nextInterval);
	}
}

static void swTimerInit(void);
MODULE_INIT_FUNCTION(swTimer, 4, swTimerInit)
static void swTimerInit(void)
{
	uint8_t i;
	g_ticksLastSetup = 0U;
	for (i = 0; i < SW_TIMER_MAX_HANDLES; ++i)
	{
		g_swTimerHandles[i].callback = NULL;
		g_swTimerHandles[i].interval = 0U;
		g_swTimerHandles[i].oneShot = false;
		g_swTimerHandles[i].tickCounter = 0;
	}
}
